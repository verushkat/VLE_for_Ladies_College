/**
 * @fileoverview added by tsickle
 * Generated from: lib/swal.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { dismissOnDestroyToken, fireOnInitToken } from './di';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of \@Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe.
 *
 * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many \@Inputs,
 *     take a look at [swalOptions], that lets you pass a full {\@link SweetAlertOptions} object.
 *
 * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
 *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
 *     If you are really concerned about performance and/or don't care about the API and its convenient integration
 *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
 *
 * /!\ Some SweetAlert options aren't \@Inputs but \@Outputs: onBeforeOpen, onOpen, onClose, onAfterClose and onDestroy
 *     (but without "on*" prefix to respect community standards).
 *     However, preConfirm and inputValidator are still \@Inputs because there are not event handlers, there can't be
 *     multiple listeners and we need the values they can/must return.
 */
export class SwalComponent {
    /**
     * @param {?} sweetAlert2Loader
     * @param {?} moduleLevelFireOnInit
     * @param {?} moduleLevelDismissOnDestroy
     */
    constructor(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.moduleLevelFireOnInit = moduleLevelFireOnInit;
        this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
        /**
         * Emits an event when the modal DOM element has been created.
         * Useful to perform DOM mutations before the modal is shown.
         */
        this.beforeOpen = new EventEmitter();
        /**
         * Emits an event when the modal is shown.
         */
        this.open = new EventEmitter();
        /**
         * Emits an event when the modal DOM is rendered.
         */
        this.render = new EventEmitter();
        /**
         * Emits an event when the modal will be closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.close = new EventEmitter();
        /**
         * Emits an event after the modal had been closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits an event after the modal had been closed.
         * The difference between {\@link destroy} and {\@link afterClose} is that the latter is called for user interactions
         * only (clicks), whereas {\@link destroy} is always called, both for user interactions and popup being closed by
         * another popup.
         */
        this.destroy = new EventEmitter();
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
         * The reason is `undefined` when {\@link dismiss} is called.
         *
         * Example:
         *     <swal (cancel)="handleCancel($event)"></swal>
         *
         *     public handleCancel(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
        /**
         * This Set retains the properties that have been changed from \@Inputs, so we can know precisely
         * what options we have to send to {\@link Swal.fire}.
         */
        this.touchedProps = new Set();
        /**
         * A function of signature `(propName: string): void` that adds a given property name to the list of
         * touched properties, ie. {\@link touchedProps}.
         */
        this.markTouched = this.touchedProps.add.bind(this.touchedProps);
        /**
         * Is the SweetAlert2 modal represented by this component currently opened?
         */
        this.isCurrentlyShown = false;
    }
    /**
     * An object of SweetAlert2 native options, useful if:
     *  - you don't want to use the \@Inputs for practical/philosophical reasons ;
     *  - there are missing \@Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
     *
     * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
     *     previous properties you want to erase again.
     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
     *
     * /!\ Be aware that the options defined in this object will override the \@Inputs of the same name.
     * @param {?} options
     * @return {?}
     */
    set swalOptions(options) {
        //=> Update properties
        Object.assign(this, options);
        //=> Mark changed properties as touched
        /** @type {?} */
        const touchedKeys = (/** @type {?} */ (Object.keys(options)));
        touchedKeys.forEach(this.markTouched);
    }
    /**
     * Computes the options object that will get passed to SweetAlert2.
     * Only the properties that have been set at least once on this component will be returned.
     * Mostly for internal usage.
     * @return {?}
     */
    get swalOptions() {
        /** @type {?} */
        const options = {};
        //=> We will compute the options object based on the option keys that are known to have changed.
        //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
        //   avoiding side effects.
        this.touchedProps.forEach((/**
         * @param {?} prop
         * @return {?}
         */
        prop => {
            options[prop] = this[(/** @type {?} */ (prop))];
        }));
        return options;
    }
    /**
     * @param {?} visible
     * @return {?}
     */
    set swalVisible(visible) {
        visible ? this.fire() : this.dismiss();
    }
    /**
     * @return {?}
     */
    get swalVisible() {
        return this.isCurrentlyShown;
    }
    /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     * @return {?}
     */
    ngOnInit() {
        //=> Preload SweetAlert2 library in case this component is activated.
        this.sweetAlert2Loader.preloadSweetAlertLibrary();
    }
    /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const fireOnInit = this.swalFireOnInit === undefined
            ? this.moduleLevelFireOnInit
            : this.swalFireOnInit;
        fireOnInit && this.fire();
    }
    /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
        //   send it with the next fire() or update() calls.
        Object.keys(changes)
            //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
            .filter((/**
         * @param {?} prop
         * @return {?}
         */
        (prop) => !prop.startsWith('swal')))
            .forEach(this.markTouched);
        //=> Eventually trigger re-render if the modal is open.
        void this.update();
    }
    /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     * @return {?}
     */
    ngOnDestroy() {
        //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
        /** @type {?} */
        const dismissOnDestroy = this.swalDismissOnDestroy === undefined
            ? this.moduleLevelDismissOnDestroy
            : this.swalDismissOnDestroy;
        dismissOnDestroy && this.dismiss();
    }
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     * @return {?}
     */
    fire() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const swal = yield this.sweetAlert2Loader.swal;
            //=> Build the SweetAlert2 options
            /** @type {?} */
            const options = Object.assign({}, this.swalOptions, { onBeforeOpen: (/**
                 * @param {?} modalElement
                 * @return {?}
                 */
                (modalElement) => {
                    this.beforeOpen.emit({ modalElement });
                }), onOpen: (/**
                 * @param {?} modalElement
                 * @return {?}
                 */
                (modalElement) => {
                    this.isCurrentlyShown = true;
                    this.open.emit({ modalElement });
                }), onRender: (/**
                 * @param {?} modalElement
                 * @return {?}
                 */
                (modalElement) => {
                    this.render.emit({ modalElement });
                }), onClose: (/**
                 * @param {?} modalElement
                 * @return {?}
                 */
                (modalElement) => {
                    this.isCurrentlyShown = false;
                    this.close.emit({ modalElement });
                }), onAfterClose: (/**
                 * @return {?}
                 */
                () => {
                    this.afterClose.emit();
                }), onDestroy: (/**
                 * @return {?}
                 */
                () => {
                    this.destroy.emit();
                }) });
            //=> Show the Swal! And wait for confirmation or dimissal.
            /** @type {?} */
            const result = yield swal.fire(options);
            //=> Emit on (confirm) or (cancel)
            if ('value' in result) {
                this.confirm.emit(result.value);
            }
            else {
                this.cancel.emit(result.dismiss);
            }
            return result;
        });
    }
    /**
     * Closes the modal, if opened.
     *
     * @param {?=} result The value that the modal will resolve with, triggering either (confirm) or (cancel).
     *               If the argument is not passed, (dimiss) will emit `undefined`.
     *               See {\@link Swal.close}
     * @return {?}
     */
    dismiss(result) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.isCurrentlyShown)
                return;
            /** @type {?} */
            const swal = yield this.sweetAlert2Loader.swal;
            swal.close(result);
        });
    }
    /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param {?=} options
     * @return {?}
     */
    update(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (options) {
                this.swalOptions = options;
            }
            if (!this.isCurrentlyShown)
                return;
            /** @type {?} */
            const swal = yield this.sweetAlert2Loader.swal;
            /** @type {?} */
            const allOptions = this.swalOptions;
            /** @type {?} */
            const updatableOptions = Object.keys(allOptions)
                .filter((/**
             * @param {?} key
             * @return {?}
             */
            (key) => swal.isUpdatableParameter(key)))
                .reduce((/**
             * @param {?} obj
             * @param {?} key
             * @return {?}
             */
            (obj, key) => {
                obj[key] = allOptions[key];
                return obj;
            }), (/** @type {?} */ ({})));
            swal.update(updatableOptions);
        });
    }
}
SwalComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'swal',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
SwalComponent.ctorParameters = () => [
    { type: SweetAlert2LoaderService },
    { type: Boolean, decorators: [{ type: Inject, args: [fireOnInitToken,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [dismissOnDestroyToken,] }] }
];
SwalComponent.propDecorators = {
    title: [{ type: Input }],
    titleText: [{ type: Input }],
    text: [{ type: Input }],
    html: [{ type: Input }],
    footer: [{ type: Input }],
    icon: [{ type: Input }],
    iconHtml: [{ type: Input }],
    backdrop: [{ type: Input }],
    toast: [{ type: Input }],
    target: [{ type: Input }],
    input: [{ type: Input }],
    width: [{ type: Input }],
    padding: [{ type: Input }],
    background: [{ type: Input }],
    position: [{ type: Input }],
    grow: [{ type: Input }],
    showClass: [{ type: Input }],
    hideClass: [{ type: Input }],
    customClass: [{ type: Input }],
    timer: [{ type: Input }],
    timerProgressBar: [{ type: Input }],
    animation: [{ type: Input }],
    heightAuto: [{ type: Input }],
    allowOutsideClick: [{ type: Input }],
    allowEscapeKey: [{ type: Input }],
    allowEnterKey: [{ type: Input }],
    stopKeydownPropagation: [{ type: Input }],
    keydownListenerCapture: [{ type: Input }],
    showConfirmButton: [{ type: Input }],
    showCancelButton: [{ type: Input }],
    confirmButtonText: [{ type: Input }],
    cancelButtonText: [{ type: Input }],
    confirmButtonColor: [{ type: Input }],
    cancelButtonColor: [{ type: Input }],
    confirmButtonAriaLabel: [{ type: Input }],
    cancelButtonAriaLabel: [{ type: Input }],
    buttonsStyling: [{ type: Input }],
    reverseButtons: [{ type: Input }],
    focusConfirm: [{ type: Input }],
    focusCancel: [{ type: Input }],
    showCloseButton: [{ type: Input }],
    closeButtonHtml: [{ type: Input }],
    closeButtonAriaLabel: [{ type: Input }],
    showLoaderOnConfirm: [{ type: Input }],
    preConfirm: [{ type: Input }],
    imageUrl: [{ type: Input }],
    imageWidth: [{ type: Input }],
    imageHeight: [{ type: Input }],
    imageAlt: [{ type: Input }],
    inputPlaceholder: [{ type: Input }],
    inputValue: [{ type: Input }],
    inputOptions: [{ type: Input }],
    inputAutoTrim: [{ type: Input }],
    inputAttributes: [{ type: Input }],
    inputValidator: [{ type: Input }],
    validationMessage: [{ type: Input }],
    progressSteps: [{ type: Input }],
    currentProgressStep: [{ type: Input }],
    progressStepsDistance: [{ type: Input }],
    scrollbarPadding: [{ type: Input }],
    swalOptions: [{ type: Input }],
    swalFireOnInit: [{ type: Input }],
    swalDismissOnDestroy: [{ type: Input }],
    swalVisible: [{ type: Input }],
    beforeOpen: [{ type: Output }],
    open: [{ type: Output }],
    render: [{ type: Output }],
    close: [{ type: Output }],
    afterClose: [{ type: Output }],
    destroy: [{ type: Output }],
    confirm: [{ type: Output }],
    cancel: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SwalComponent.prototype.title;
    /** @type {?} */
    SwalComponent.prototype.titleText;
    /** @type {?} */
    SwalComponent.prototype.text;
    /** @type {?} */
    SwalComponent.prototype.html;
    /** @type {?} */
    SwalComponent.prototype.footer;
    /** @type {?} */
    SwalComponent.prototype.icon;
    /** @type {?} */
    SwalComponent.prototype.iconHtml;
    /** @type {?} */
    SwalComponent.prototype.backdrop;
    /** @type {?} */
    SwalComponent.prototype.toast;
    /** @type {?} */
    SwalComponent.prototype.target;
    /** @type {?} */
    SwalComponent.prototype.input;
    /** @type {?} */
    SwalComponent.prototype.width;
    /** @type {?} */
    SwalComponent.prototype.padding;
    /** @type {?} */
    SwalComponent.prototype.background;
    /** @type {?} */
    SwalComponent.prototype.position;
    /** @type {?} */
    SwalComponent.prototype.grow;
    /** @type {?} */
    SwalComponent.prototype.showClass;
    /** @type {?} */
    SwalComponent.prototype.hideClass;
    /** @type {?} */
    SwalComponent.prototype.customClass;
    /** @type {?} */
    SwalComponent.prototype.timer;
    /** @type {?} */
    SwalComponent.prototype.timerProgressBar;
    /**
     * @deprecated Use showClass and hideClass instead
     * @type {?}
     */
    SwalComponent.prototype.animation;
    /** @type {?} */
    SwalComponent.prototype.heightAuto;
    /** @type {?} */
    SwalComponent.prototype.allowOutsideClick;
    /** @type {?} */
    SwalComponent.prototype.allowEscapeKey;
    /** @type {?} */
    SwalComponent.prototype.allowEnterKey;
    /** @type {?} */
    SwalComponent.prototype.stopKeydownPropagation;
    /** @type {?} */
    SwalComponent.prototype.keydownListenerCapture;
    /** @type {?} */
    SwalComponent.prototype.showConfirmButton;
    /** @type {?} */
    SwalComponent.prototype.showCancelButton;
    /** @type {?} */
    SwalComponent.prototype.confirmButtonText;
    /** @type {?} */
    SwalComponent.prototype.cancelButtonText;
    /** @type {?} */
    SwalComponent.prototype.confirmButtonColor;
    /** @type {?} */
    SwalComponent.prototype.cancelButtonColor;
    /** @type {?} */
    SwalComponent.prototype.confirmButtonAriaLabel;
    /** @type {?} */
    SwalComponent.prototype.cancelButtonAriaLabel;
    /** @type {?} */
    SwalComponent.prototype.buttonsStyling;
    /** @type {?} */
    SwalComponent.prototype.reverseButtons;
    /** @type {?} */
    SwalComponent.prototype.focusConfirm;
    /** @type {?} */
    SwalComponent.prototype.focusCancel;
    /** @type {?} */
    SwalComponent.prototype.showCloseButton;
    /** @type {?} */
    SwalComponent.prototype.closeButtonHtml;
    /** @type {?} */
    SwalComponent.prototype.closeButtonAriaLabel;
    /** @type {?} */
    SwalComponent.prototype.showLoaderOnConfirm;
    /** @type {?} */
    SwalComponent.prototype.preConfirm;
    /** @type {?} */
    SwalComponent.prototype.imageUrl;
    /** @type {?} */
    SwalComponent.prototype.imageWidth;
    /** @type {?} */
    SwalComponent.prototype.imageHeight;
    /** @type {?} */
    SwalComponent.prototype.imageAlt;
    /** @type {?} */
    SwalComponent.prototype.inputPlaceholder;
    /** @type {?} */
    SwalComponent.prototype.inputValue;
    /** @type {?} */
    SwalComponent.prototype.inputOptions;
    /** @type {?} */
    SwalComponent.prototype.inputAutoTrim;
    /** @type {?} */
    SwalComponent.prototype.inputAttributes;
    /** @type {?} */
    SwalComponent.prototype.inputValidator;
    /** @type {?} */
    SwalComponent.prototype.validationMessage;
    /** @type {?} */
    SwalComponent.prototype.progressSteps;
    /** @type {?} */
    SwalComponent.prototype.currentProgressStep;
    /** @type {?} */
    SwalComponent.prototype.progressStepsDistance;
    /** @type {?} */
    SwalComponent.prototype.scrollbarPadding;
    /**
     * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.
     * When left undefined (default), the value will be inherited from the module configuration, which is `false`.
     *
     * Example:
     *     <swal *ngIf="error" [title]="error.title" [text]="error.text" icon="error" [swalFireOnInit]="true"></swal>
     * @type {?}
     */
    SwalComponent.prototype.swalFireOnInit;
    /**
     * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.
     * When left undefined (default), the value will be inherited from the module configuration, which is `true`.
     * @type {?}
     */
    SwalComponent.prototype.swalDismissOnDestroy;
    /**
     * Emits an event when the modal DOM element has been created.
     * Useful to perform DOM mutations before the modal is shown.
     * @type {?}
     */
    SwalComponent.prototype.beforeOpen;
    /**
     * Emits an event when the modal is shown.
     * @type {?}
     */
    SwalComponent.prototype.open;
    /**
     * Emits an event when the modal DOM is rendered.
     * @type {?}
     */
    SwalComponent.prototype.render;
    /**
     * Emits an event when the modal will be closed.
     * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
     * @type {?}
     */
    SwalComponent.prototype.close;
    /**
     * Emits an event after the modal had been closed.
     * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
     * @type {?}
     */
    SwalComponent.prototype.afterClose;
    /**
     * Emits an event after the modal had been closed.
     * The difference between {\@link destroy} and {\@link afterClose} is that the latter is called for user interactions
     * only (clicks), whereas {\@link destroy} is always called, both for user interactions and popup being closed by
     * another popup.
     * @type {?}
     */
    SwalComponent.prototype.destroy;
    /**
     * Emits when the user clicks "Confirm".
     * Bears a value when using "input", resolved "preConfirm", etc.
     *
     * Example:
     *     <swal (confirm)="handleConfirm($event)"></swal>
     *
     *     public handleConfirm(email: string): void {
     *         // ... save user email
     *     }
     * @type {?}
     */
    SwalComponent.prototype.confirm;
    /**
     * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
     * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
     * The reason is `undefined` when {\@link dismiss} is called.
     *
     * Example:
     *     <swal (cancel)="handleCancel($event)"></swal>
     *
     *     public handleCancel(reason: DismissReason | undefined): void {
     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
     *         // ... do something
     *     }
     * @type {?}
     */
    SwalComponent.prototype.cancel;
    /**
     * This Set retains the properties that have been changed from \@Inputs, so we can know precisely
     * what options we have to send to {\@link Swal.fire}.
     * @type {?}
     * @private
     */
    SwalComponent.prototype.touchedProps;
    /**
     * A function of signature `(propName: string): void` that adds a given property name to the list of
     * touched properties, ie. {\@link touchedProps}.
     * @type {?}
     * @private
     */
    SwalComponent.prototype.markTouched;
    /**
     * Is the SweetAlert2 modal represented by this component currently opened?
     * @type {?}
     * @private
     */
    SwalComponent.prototype.isCurrentlyShown;
    /**
     * @type {?}
     * @private
     */
    SwalComponent.prototype.sweetAlert2Loader;
    /**
     * @type {?}
     * @private
     */
    SwalComponent.prototype.moduleLevelFireOnInit;
    /**
     * @type {?}
     * @private
     */
    SwalComponent.prototype.moduleLevelDismissOnDestroy;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyLyIsInNvdXJjZXMiOlsibGliL3N3YWwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFFSCx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQWdDLE1BQU0sRUFDeEcsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLGVBQWUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU5RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJ4RSxNQUFNLE9BQU8sYUFBYTs7Ozs7O0lBeU50QixZQUNxQixpQkFBMkMsRUFDbEIscUJBQThCLEVBQ3hCLDJCQUFvQztRQUZuRSxzQkFBaUIsR0FBakIsaUJBQWlCLENBQTBCO1FBQ2xCLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBUztRQUN4QixnQ0FBMkIsR0FBM0IsMkJBQTJCLENBQVM7Ozs7O1FBdkZ4RSxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQTBCLENBQUM7Ozs7UUFNeEQsU0FBSSxHQUFHLElBQUksWUFBWSxFQUFvQixDQUFDOzs7O1FBTTVDLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBc0IsQ0FBQzs7Ozs7UUFPaEQsVUFBSyxHQUFHLElBQUksWUFBWSxFQUFxQixDQUFDOzs7OztRQU85QyxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQzs7Ozs7OztRQVN0QyxZQUFPLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQzs7Ozs7Ozs7Ozs7O1FBY25DLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDOzs7Ozs7Ozs7Ozs7OztRQWdCbEMsV0FBTSxHQUFHLElBQUksWUFBWSxFQUFrQyxDQUFDOzs7OztRQU0zRCxpQkFBWSxHQUFHLElB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QUFtRTs7Ozs7OztJQU1uRSxvQ0FBNkU7Ozs7OztJQUs3RSx5Q0FBaUM7Ozs7O0lBRzdCLDBDQUE0RDs7Ozs7SUFDNUQsOENBQXdFOzs7OztJQUN4RSxvREFBb0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbmplY3QsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgU3dhbCwgeyBTd2VldEFsZXJ0T3B0aW9ucywgU3dlZXRBbGVydFJlc3VsdCB9IGZyb20gJ3N3ZWV0YWxlcnQyJztcbmltcG9ydCB7IGRpc21pc3NPbkRlc3Ryb3lUb2tlbiwgZmlyZU9uSW5pdFRva2VuIH0gZnJvbSAnLi9kaSc7XG5pbXBvcnQgKiBhcyBldmVudHMgZnJvbSAnLi9zd2FsLWV2ZW50cyc7XG5pbXBvcnQgeyBTd2VldEFsZXJ0MkxvYWRlclNlcnZpY2UgfSBmcm9tICcuL3N3ZWV0YWxlcnQyLWxvYWRlci5zZXJ2aWNlJztcblxuLyoqXG4gKiA8c3dhbD4gY29tcG9uZW50LiBTZWUgdGhlIFJFQURNRS5tZCBmb3IgdXNhZ2UuXG4gKlxuICogSXQgY29udGFpbnMgYSBidW5jaCBvZiBASW5wdXRzIHRoYXQgaGF2ZSBhIHBlcmZlY3QgMToxIG1hcHBpbmcgd2l0aCBTd2VldEFsZXJ0MiBvcHRpb25zLlxuICogVGhlaXIgdHlwZXMgYXJlIGRpcmVjdGx5IGNvbWluZyBmcm9tIFN3ZWV0QWxlcnQyIHR5cGVzIGRlZmludGl0aW9ucywgbWVhbmluZyB0aGF0IG5neC1zd2VldGFsZXJ0MiBpcyB0aWdodGx5IGNvdXBsZWRcbiAqIHRvIFN3ZWV0QWxlcnQyLCBidXQgYWxzbyBpcyB0eXBlLXNhZmUuXG4gKlxuICogKD8pIElmIHlvdSB3YW50IHRvIHVzZSBhbiBvYmplY3QgdGhhdCBkZWNsYXJlcyB0aGUgU3dlZXRBbGVydDIgb3B0aW9ucyBhbGwgYXQgb25jZSByYXRoZXIgdGhhbiBtYW55IEBJbnB1dHMsXG4gKiAgICAgdGFrZSBhIGxvb2sgYXQgW3N3YWxPcHRpb25zXSwgdGhhdCBsZXRzIHlvdSBwYXNzIGEgZnVsbCB7QGxpbmsgU3dlZXRBbGVydE9wdGlvbnN9IG9iamVjdC5cbiAqXG4gKiAoPykgSWYgeW91IGFyZSByZWFkaW5nIHRoZSBUeXBlU2NyaXB0IHNvdXJjZSBvZiB0aGlzIGNvbXBvbmVudCwgeW91IG1heSB0aGluayB0aGF0IGl0J3MgYSBsb3Qgb2YgY29kZS5cbiAqICAgICBCZSBzdXJlIHRoYXQgYSBsb3Qgb2YgdGhpcyBjb2RlIGlzIHR5cGVzIGFuZCBBbmd1bGFyIGJvaWxlcnBsYXRlLiBDb21waWxlZCBhbmQgbWluaWZpZWQgY29kZSBpcyBtdWNoIHNtYWxsZXIuXG4gKiAgICAgSWYgeW91IGFyZSByZWFsbHkgY29uY2VybmVkIGFib3V0IHBlcmZvcm1hbmNlIGFuZC9vciBkb24ndCBjYXJlIGFib3V0IHRoZSBBUEkgYW5kIGl0cyBjb252ZW5pZW50IGludGVncmF0aW9uXG4gKiAgICAgd2l0aCBBbmd1bGFyIChub3RhYmx5IGNoYW5nZSBkZXRlY3Rpb24gYW5kIHRyYW5zY2x1c2lvbiksIHlvdSBtYXkgdG90YWxseSB1c2UgU3dlZXRBbGVydDIgbmF0aXZlbHkgYXMgd2VsbCA7KVxuICpcbiAqIC8hXFwgU29tZSBTd2VldEFsZXJ0IG9wdGlvbnMgYXJlbid0IEBJbnB1dHMgYnV0IEBPdXRwdXRzOiBvbkJlZm9yZU9wZW4sIG9uT3Blbiwgb25DbG9zZSwgb25BZnRlckNsb3NlIGFuZCBvbkRlc3Ryb3lcbiAqICAgICAoYnV0IHdpdGhvdXQgXCJvbipcIiBwcmVmaXggdG8gcmVzcGVjdCBjb21tdW5pdHkgc3RhbmRhcmRzKS5cbiAqICAgICBIb3dldmVyLCBwcmVDb25maXJtIGFuZCBpbnB1dFZhbGlkYXRvciBhcmUgc3RpbGwgQElucHV0cyBiZWNhdXNlIHRoZXJlIGFyZSBub3QgZXZlbnQgaGFuZGxlcnMsIHRoZXJlIGNhbid0IGJlXG4gKiAgICAgbXVsdGlwbGUgbGlzdGVuZXJzIGFuZCB3ZSBuZWVkIHRoZSB2YWx1ZXMgdGhleSBjYW4vbXVzdCByZXR1cm4uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3JcbiAgICBzZWxlY3RvcjogJ3N3YWwnLFxuICAgIHRlbXBsYXRlOiAnJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTd2FsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgQElucHV0KCkgcHVibGljIHRpdGxlOiBTd2VldEFsZXJ0T3B0aW9uc1sndGl0bGUnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGl0bGVUZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1sndGl0bGVUZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIHRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0ZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGh0bWw6IFN3ZWV0QWxlcnRPcHRpb25zWydodG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvb3RlcjogU3dlZXRBbGVydE9wdGlvbnNbJ2Zvb3RlciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpY29uOiBTd2VldEFsZXJ0T3B0aW9uc1snaWNvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpY29uSHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2ljb25IdG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tkcm9wOiBTd2VldEFsZXJ0T3B0aW9uc1snYmFja2Ryb3AnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdG9hc3Q6IFN3ZWV0QWxlcnRPcHRpb25zWyd0b2FzdCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0YXJnZXQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0YXJnZXQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB3aWR0aDogU3dlZXRBbGVydE9wdGlvbnNbJ3dpZHRoJ107XG4gICAgQElucHV0KCkgcHVibGljIHBhZGRpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydwYWRkaW5nJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tncm91bmQ6IFN3ZWV0QWxlcnRPcHRpb25zWydiYWNrZ3JvdW5kJ107XG4gICAgQElucHV0KCkgcHVibGljIHBvc2l0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1sncG9zaXRpb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZ3JvdzogU3dlZXRBbGVydE9wdGlvbnNbJ2dyb3cnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NsYXNzOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIGhpZGVDbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2hpZGVDbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjdXN0b21DbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2N1c3RvbUNsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIHRpbWVyOiBTd2VldEFsZXJ0T3B0aW9uc1sndGltZXInXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGltZXJQcm9ncmVzc0JhcjogU3dlZXRBbGVydE9wdGlvbnNbJ3RpbWVyUHJvZ3Jlc3NCYXInXTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIHNob3dDbGFzcyBhbmQgaGlkZUNsYXNzIGluc3RlYWQgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgYW5pbWF0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1snYW5pbWF0aW9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGhlaWdodEF1dG86IFN3ZWV0QWxlcnRPcHRpb25zWydoZWlnaHRBdXRvJ107XG4gICAgQElucHV0KCkgcHVibGljIGFsbG93T3V0c2lkZUNsaWNrOiBTd2VldEFsZXJ0T3B0aW9uc1snYWxsb3dPdXRzaWRlQ2xpY2snXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYWxsb3dFc2NhcGVLZXk6IFN3ZWV0QWxlcnRPcHRpb25zWydhbGxvd0VzY2FwZUtleSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd0VudGVyS2V5OiBTd2VldEFsZXJ0T3B0aW9uc1snYWxsb3dFbnRlcktleSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzdG9wS2V5ZG93blByb3BhZ2F0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc3RvcEtleWRvd25Qcm9wYWdhdGlvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBrZXlkb3duTGlzdGVuZXJDYXB0dXJlOiBTd2VldEFsZXJ0T3B0aW9uc1sna2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q29uZmlybUJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDb25maXJtQnV0dG9uJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDYW5jZWxCdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q2FuY2VsQnV0dG9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25UZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1snY29uZmlybUJ1dHRvblRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2FuY2VsQnV0dG9uVGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvblRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY29uZmlybUJ1dHRvbkNvbG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snY29uZmlybUJ1dHRvbkNvbG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIGNhbmNlbEJ1dHRvbkNvbG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snY2FuY2VsQnV0dG9uQ29sb3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY29uZmlybUJ1dHRvbkFyaWFMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2FuY2VsQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY2FuY2VsQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIGJ1dHRvbnNTdHlsaW5nOiBTd2VldEFsZXJ0T3B0aW9uc1snYnV0dG9uc1N0eWxpbmcnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcmV2ZXJzZUJ1dHRvbnM6IFN3ZWV0QWxlcnRPcHRpb25zWydyZXZlcnNlQnV0dG9ucyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmb2N1c0NvbmZpcm06IFN3ZWV0QWxlcnRPcHRpb25zWydmb2N1c0NvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9jdXNDYW5jZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydmb2N1c0NhbmNlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q2xvc2VCdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q2xvc2VCdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2xvc2VCdXR0b25IdG1sOiBTd2VldEFsZXJ0T3B0aW9uc1snY2xvc2VCdXR0b25IdG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIGNsb3NlQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY2xvc2VCdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0xvYWRlck9uQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dMb2FkZXJPbkNvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJlQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ3ByZUNvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VVcmw6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZVVybCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZVdpZHRoOiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VXaWR0aCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZUhlaWdodDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlSGVpZ2h0J107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlQWx0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VBbHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRQbGFjZWhvbGRlcjogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0UGxhY2Vob2xkZXInXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRWYWx1ZTogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsdWUnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRPcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRPcHRpb25zJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0QXV0b1RyaW06IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dEF1dG9UcmltJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0QXR0cmlidXRlczogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0QXR0cmlidXRlcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dFZhbGlkYXRvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsaWRhdG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIHZhbGlkYXRpb25NZXNzYWdlOiBTd2VldEFsZXJ0T3B0aW9uc1sndmFsaWRhdGlvbk1lc3NhZ2UnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJvZ3Jlc3NTdGVwczogU3dlZXRBbGVydE9wdGlvbnNbJ3Byb2dyZXNzU3RlcHMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY3VycmVudFByb2dyZXNzU3RlcDogU3dlZXRBbGVydE9wdGlvbnNbJ2N1cnJlbnRQcm9ncmVzc1N0ZXAnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlOiBTd2VldEFsZXJ0T3B0aW9uc1sncHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlJ107XG4gICAgQElucHV0KCkgcHVibGljIHNjcm9sbGJhclBhZGRpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydzY3JvbGxiYXJQYWRkaW5nJ107XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3Qgb2YgU3dlZXRBbGVydDIgbmF0aXZlIG9wdGlvbnMsIHVzZWZ1bCBpZjpcbiAgICAgKiAgLSB5b3UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIEBJbnB1dHMgZm9yIHByYWN0aWNhbC9waGlsb3NvcGhpY2FsIHJlYXNvbnMgO1xuICAgICAqICAtIHRoZXJlIGFyZSBtaXNzaW5nIEBJbnB1dHMgYmVjYXVzZSBuZ3gtc3dlZXRhbGVydDIgaXNuJ3QgdXAtdG8tZGF0ZSB3aXRoIFN3ZWV0QWxlcnQyJ3MgbGF0ZXN0IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiAvIVxcIFBsZWFzZSBub3RlIHRoYXQgc2V0dGluZyB0aGlzIHByb3BlcnR5IGRvZXMgTk9UIGVyYXNlIHdoYXQgaGFzIGJlZW4gc2V0IGJlZm9yZSB1bmxlc3MgeW91IHNwZWNpZnkgdGhlXG4gICAgICogICAgIHByZXZpb3VzIHByb3BlcnRpZXMgeW91IHdhbnQgdG8gZXJhc2UgYWdhaW4uXG4gICAgICogICAgIEllLiBzZXR0aW5nIHsgdGl0bGU6ICdUaXRsZScgfSBhbmQgdGhlbiB7IHRleHQ6ICdUZXh0JyB9IHdpbGwgZ2l2ZSB7IHRpdGxlOiAnVGl0bGUnLCB0ZXh0OiAnVGV4dCcgfS5cbiAgICAgKlxuICAgICAqIC8hXFwgQmUgYXdhcmUgdGhhdCB0aGUgb3B0aW9ucyBkZWZpbmVkIGluIHRoaXMgb2JqZWN0IHdpbGwgb3ZlcnJpZGUgdGhlIEBJbnB1dHMgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgc3dhbE9wdGlvbnMob3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMpIHtcbiAgICAgICAgLy89PiBVcGRhdGUgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vPT4gTWFyayBjaGFuZ2VkIHByb3BlcnRpZXMgYXMgdG91Y2hlZFxuICAgICAgICBjb25zdCB0b3VjaGVkS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpIGFzIEFycmF5PGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zPjtcbiAgICAgICAgdG91Y2hlZEtleXMuZm9yRWFjaCh0aGlzLm1hcmtUb3VjaGVkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgb3B0aW9ucyBvYmplY3QgdGhhdCB3aWxsIGdldCBwYXNzZWQgdG8gU3dlZXRBbGVydDIuXG4gICAgICogT25seSB0aGUgcHJvcGVydGllcyB0aGF0IGhhdmUgYmVlbiBzZXQgYXQgbGVhc3Qgb25jZSBvbiB0aGlzIGNvbXBvbmVudCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIE1vc3RseSBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gICAgICovXG4gICAgcHVibGljIGdldCBzd2FsT3B0aW9ucygpOiBTd2VldEFsZXJ0T3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IHsgW1AgaW4ga2V5b2YgU3dlZXRBbGVydE9wdGlvbnNdOiBhbnkgfSA9IHt9O1xuXG4gICAgICAgIC8vPT4gV2Ugd2lsbCBjb21wdXRlIHRoZSBvcHRpb25zIG9iamVjdCBiYXNlZCBvbiB0aGUgb3B0aW9uIGtleXMgdGhhdCBhcmUga25vd24gdG8gaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAvLyAgIFRoYXQgYXZvaWRzIHBhc3NpbmcgYSBnaWdhbnRpYyBvYmplY3QgdG8gU3dlZXRBbGVydDIsIG1ha2luZyBkZWJ1Z2dpbmcgZWFzaWVyIGFuZCBwb3RlbnRpYWxseVxuICAgICAgICAvLyAgIGF2b2lkaW5nIHNpZGUgZWZmZWN0cy5cbiAgICAgICAgdGhpcy50b3VjaGVkUHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgIG9wdGlvbnNbcHJvcF0gPSB0aGlzW3Byb3AgYXMga2V5b2YgdGhpc107XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZmlyZSB0aGUgbW9kYWwgYXMgc29vbiBhcyB0aGUgPHN3YWw+IGNvbXBvbmVudCBpcyBjcmVhdGVkIGFuZCBpbml0aWFsaXplZCBpbiB0aGUgdmlldy5cbiAgICAgKiBXaGVuIGxlZnQgdW5kZWZpbmVkIChkZWZhdWx0KSwgdGhlIHZhbHVlIHdpbGwgYmUgaW5oZXJpdGVkIGZyb20gdGhlIG1vZHVsZSBjb25maWd1cmF0aW9uLCB3aGljaCBpcyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgPHN3YWwgKm5nSWY9XCJlcnJvclwiIFt0aXRsZV09XCJlcnJvci50aXRsZVwiIFt0ZXh0XT1cImVycm9yLnRleHRcIiBpY29uPVwiZXJyb3JcIiBbc3dhbEZpcmVPbkluaXRdPVwidHJ1ZVwiPjwvc3dhbD5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzd2FsRmlyZU9uSW5pdD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGRpc21pc3MgdGhlIG1vZGFsIHdoZW4gdGhlIDxzd2FsPiBjb21wb25lbnQgaXMgZGVzdHJveWVkIGJ5IEFuZ3VsYXIgKGZvciBhbnkgcmVhc29uKSBvciBub3QuXG4gICAgICogV2hlbiBsZWZ0IHVuZGVmaW5lZCAoZGVmYXVsdCksIHRoZSB2YWx1ZSB3aWxsIGJlIGluaGVyaXRlZCBmcm9tIHRoZSBtb2R1bGUgY29uZmlndXJhdGlvbiwgd2hpY2ggaXMgYHRydWVgLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN3YWxEaXNtaXNzT25EZXN0cm95PzogYm9vbGVhbjtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBzd2FsVmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKSB7XG4gICAgICAgIHZpc2libGUgPyB0aGlzLmZpcmUoKSA6IHRoaXMuZGlzbWlzcygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc3dhbFZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQ3VycmVudGx5U2hvd247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbW9kYWwgRE9NIGVsZW1lbnQgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKiBVc2VmdWwgdG8gcGVyZm9ybSBET00gbXV0YXRpb25zIGJlZm9yZSB0aGUgbW9kYWwgaXMgc2hvd24uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGJlZm9yZU9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5CZWZvcmVPcGVuRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBtb2RhbCBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgb3BlbiA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLk9wZW5FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG1vZGFsIERPTSBpcyByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgcmVuZGVyID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuUmVuZGVyRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBtb2RhbCB3aWxsIGJlIGNsb3NlZC5cbiAgICAgKiBJZiB5b3UganVzdCB3YW50IHRvIGtub3cgd2hlbiB0aGUgdXNlciBkaXNtaXNzZWQgdGhlIG1vZGFsLCBwcmVmZXIgdGhlIGhpZ2hlci1sZXZlbCAoY2FuY2VsKSBvdXRwdXQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuQ2xvc2VFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSBtb2RhbCBoYWQgYmVlbiBjbG9zZWQuXG4gICAgICogSWYgeW91IGp1c3Qgd2FudCB0byBrbm93IHdoZW4gdGhlIHVzZXIgZGlzbWlzc2VkIHRoZSBtb2RhbCwgcHJlZmVyIHRoZSBoaWdoZXItbGV2ZWwgKGNhbmNlbCkgb3V0cHV0LlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBhZnRlckNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIG1vZGFsIGhhZCBiZWVuIGNsb3NlZC5cbiAgICAgKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHtAbGluayBkZXN0cm95fSBhbmQge0BsaW5rIGFmdGVyQ2xvc2V9IGlzIHRoYXQgdGhlIGxhdHRlciBpcyBjYWxsZWQgZm9yIHVzZXIgaW50ZXJhY3Rpb25zXG4gICAgICogb25seSAoY2xpY2tzKSwgd2hlcmVhcyB7QGxpbmsgZGVzdHJveX0gaXMgYWx3YXlzIGNhbGxlZCwgYm90aCBmb3IgdXNlciBpbnRlcmFjdGlvbnMgYW5kIHBvcHVwIGJlaW5nIGNsb3NlZCBieVxuICAgICAqIGFub3RoZXIgcG9wdXAuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGRlc3Ryb3kgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNvbmZpcm1cIi5cbiAgICAgKiBCZWFycyBhIHZhbHVlIHdoZW4gdXNpbmcgXCJpbnB1dFwiLCByZXNvbHZlZCBcInByZUNvbmZpcm1cIiwgZXRjLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgPHN3YWwgKGNvbmZpcm0pPVwiaGFuZGxlQ29uZmlybSgkZXZlbnQpXCI+PC9zd2FsPlxuICAgICAqXG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVDb25maXJtKGVtYWlsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIC4uLiBzYXZlIHVzZXIgZW1haWxcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBjb25maXJtID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNhbmNlbFwiLCBvciBkaXNtaXNzZXMgdGhlIG1vZGFsIGJ5IGFueSBvdGhlciBhbGxvd2VkIHdheS5cbiAgICAgKiBCeSBkZWZhdWx0LCBpdCB3aWxsIGVtaXQgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByZWFzb24gZm9yIHdoaWNoIHRoZSBTd2VldEFsZXJ0IGhhcyBiZWVuIGNsb3NlZC5cbiAgICAgKiBUaGUgcmVhc29uIGlzIGB1bmRlZmluZWRgIHdoZW4ge0BsaW5rIGRpc21pc3N9IGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsIChjYW5jZWwpPVwiaGFuZGxlQ2FuY2VsKCRldmVudClcIj48L3N3YWw+XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNhbmNlbChyZWFzb246IERpc21pc3NSZWFzb24gfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIHJlYXNvbiBjYW4gYmUgJ2NhbmNlbCcsICdvdmVybGF5JywgJ2Nsb3NlJywgJ3RpbWVyJyBvciB1bmRlZmluZWQuXG4gICAgICogICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nXG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjxTd2FsLkRpc21pc3NSZWFzb24gfCB1bmRlZmluZWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIFNldCByZXRhaW5zIHRoZSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIGNoYW5nZWQgZnJvbSBASW5wdXRzLCBzbyB3ZSBjYW4ga25vdyBwcmVjaXNlbHlcbiAgICAgKiB3aGF0IG9wdGlvbnMgd2UgaGF2ZSB0byBzZW5kIHRvIHtAbGluayBTd2FsLmZpcmV9LlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgdG91Y2hlZFByb3BzID0gbmV3IFNldDxrZXlvZiBTd2VldEFsZXJ0T3B0aW9ucz4oKTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gb2Ygc2lnbmF0dXJlIGAocHJvcE5hbWU6IHN0cmluZyk6IHZvaWRgIHRoYXQgYWRkcyBhIGdpdmVuIHByb3BlcnR5IG5hbWUgdG8gdGhlIGxpc3Qgb2ZcbiAgICAgKiB0b3VjaGVkIHByb3BlcnRpZXMsIGllLiB7QGxpbmsgdG91Y2hlZFByb3BzfS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IG1hcmtUb3VjaGVkID0gdGhpcy50b3VjaGVkUHJvcHMuYWRkLmJpbmQodGhpcy50b3VjaGVkUHJvcHMpO1xuXG4gICAgLyoqXG4gICAgICogSXMgdGhlIFN3ZWV0QWxlcnQyIG1vZGFsIHJlcHJlc2VudGVkIGJ5IHRoaXMgY29tcG9uZW50IGN1cnJlbnRseSBvcGVuZWQ/XG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0N1cnJlbnRseVNob3duID0gZmFsc2U7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgc3dlZXRBbGVydDJMb2FkZXI6IFN3ZWV0QWxlcnQyTG9hZGVyU2VydmljZSxcbiAgICAgICAgQEluamVjdChmaXJlT25Jbml0VG9rZW4pIHByaXZhdGUgcmVhZG9ubHkgbW9kdWxlTGV2ZWxGaXJlT25Jbml0OiBib29sZWFuLFxuICAgICAgICBASW5qZWN0KGRpc21pc3NPbkRlc3Ryb3lUb2tlbikgcHJpdmF0ZSByZWFkb25seSBtb2R1bGVMZXZlbERpc21pc3NPbkRlc3Ryb3k6IGJvb2xlYW4pIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGxpZmVjeWNsZSBob29rLlxuICAgICAqIEFza3MgdGhlIFN3ZWV0QWxlcnQyIGxvYWRlciBzZXJ2aWNlIHRvIHByZWxvYWQgdGhlIFN3ZWV0QWxlcnQyIGxpYnJhcnksIHNvIGl0IGJlZ2lucyB0byBiZSBsb2FkZWQgb25seSBpZiB0aGVyZVxuICAgICAqIGlzIGEgPHN3YWw+IGNvbXBvbmVudCBzb21ld2hlcmUsIGFuZCBpcyBwcm9iYWJseSBmdWxseSBsb2FkZWQgd2hlbiB0aGUgbW9kYWwgaGFzIHRvIGJlIGRpc3BsYXllZCxcbiAgICAgKiBjYXVzaW5nIG5vIGRlbGF5LlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy89PiBQcmVsb2FkIFN3ZWV0QWxlcnQyIGxpYnJhcnkgaW4gY2FzZSB0aGlzIGNvbXBvbmVudCBpcyBhY3RpdmF0ZWQuXG4gICAgICAgIHRoaXMuc3dlZXRBbGVydDJMb2FkZXIucHJlbG9hZFN3ZWV0QWxlcnRMaWJyYXJ5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBGaXJlcyB0aGUgbW9kYWwsIGlmIHRoZSBjb21wb25lbnQgb3IgbW9kdWxlIGlzIGNvbmZpZ3VyZWQgdG8gZG8gc28uXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZmlyZU9uSW5pdCA9IHRoaXMuc3dhbEZpcmVPbkluaXQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0aGlzLm1vZHVsZUxldmVsRmlyZU9uSW5pdFxuICAgICAgICAgICAgOiB0aGlzLnN3YWxGaXJlT25Jbml0O1xuXG4gICAgICAgIGZpcmVPbkluaXQgJiYgdGhpcy5maXJlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBVcGRhdGVzIHRoZSBTd2VldEFsZXJ0IG9wdGlvbnMsIGFuZCBpZiB0aGUgbW9kYWwgaXMgb3BlbmVkLCBhc2tzIFN3ZWV0QWxlcnQgdG8gcmVuZGVyIGl0IGFnYWluLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIC8vPT4gRm9yIGVhY2ggY2hhbmdlZCBASW5wdXQgdGhhdCBtYXRjaGVzIGEgU3dlZXRBbGVydDIgb3B0aW9uLCBtYXJrIGFzIHRvdWNoZWQgc28gd2UgY2FuXG4gICAgICAgIC8vICAgc2VuZCBpdCB3aXRoIHRoZSBuZXh0IGZpcmUoKSBvciB1cGRhdGUoKSBjYWxscy5cbiAgICAgICAgT2JqZWN0LmtleXMoY2hhbmdlcylcbiAgICAgICAgICAgIC8vPT4gSWYgdGhlIGZpbHRlcmluZyBsb2dpYyBiZWNvbWVzIG1vcmUgY29tcGxleCBoZXJlLCB3ZSBjYW4gdXNlIFN3YWwuaXNWYWxpZFBhcmFtZXRlclxuICAgICAgICAgICAgLmZpbHRlcigocHJvcCk6IHByb3AgaXMga2V5b2YgU3dlZXRBbGVydE9wdGlvbnMgPT4gIXByb3Auc3RhcnRzV2l0aCgnc3dhbCcpKVxuICAgICAgICAgICAgLmZvckVhY2godGhpcy5tYXJrVG91Y2hlZCk7XG5cbiAgICAgICAgLy89PiBFdmVudHVhbGx5IHRyaWdnZXIgcmUtcmVuZGVyIGlmIHRoZSBtb2RhbCBpcyBvcGVuLlxuICAgICAgICB2b2lkIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBDbG9zZXMgdGhlIFN3ZWV0QWxlcnQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIC8vPT4gUmVsZWFzZSB0aGUgbW9kYWwgaWYgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgYW5kIGlmIHRoYXQgYmVoYXZpb3VyIGlzIG5vdCBkaXNhYmxlZC5cbiAgICAgICAgY29uc3QgZGlzbWlzc09uRGVzdHJveSA9IHRoaXMuc3dhbERpc21pc3NPbkRlc3Ryb3kgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0aGlzLm1vZHVsZUxldmVsRGlzbWlzc09uRGVzdHJveVxuICAgICAgICAgICAgOiB0aGlzLnN3YWxEaXNtaXNzT25EZXN0cm95O1xuXG4gICAgICAgIGRpc21pc3NPbkRlc3Ryb3kgJiYgdGhpcy5kaXNtaXNzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIFN3ZWV0QWxlcnQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBTd2VldEFsZXJ0MiBwcm9taXNlIGZvciBjb252ZW5pZW5jZSBhbmQgdXNlIGluIGNvZGUgYmVoaW5kIHRlbXBsYXRlcy5cbiAgICAgKiBPdGhlcndpc2UsIChjb25maXJtKT1cIm15SGFuZGxlcigkZXZlbnQpXCIgYW5kIChjYW5jZWwpPVwibXlIYW5kbGVyKCRldmVudClcIiBjYW4gYmUgdXNlZCBpbiB0ZW1wbGF0ZXMuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGZpcmUoKTogUHJvbWlzZTxTd2VldEFsZXJ0UmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IHN3YWwgPSBhd2FpdCB0aGlzLnN3ZWV0QWxlcnQyTG9hZGVyLnN3YWw7XG5cbiAgICAgICAgLy89PiBCdWlsZCB0aGUgU3dlZXRBbGVydDIgb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vPT4gTWVyZ2Ugd2l0aCBjYWxjdWxhdGVkIG9wdGlvbnMgc2V0IGZvciB0aGF0IHNwZWNpZmljIHN3YWxcbiAgICAgICAgICAgIC4uLnRoaXMuc3dhbE9wdGlvbnMsXG5cbiAgICAgICAgICAgIC8vPT4gSGFuZGxlIG1vZGFsIGxpZmVjeWNsZSBldmVudHNcbiAgICAgICAgICAgIG9uQmVmb3JlT3BlbjogKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVmb3JlT3Blbi5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uT3BlbjogKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlTaG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZW5kZXI6IChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlci5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2xvc2U6IChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ3VycmVudGx5U2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25BZnRlckNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZnRlckNsb3NlLmVtaXQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3kuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vPT4gU2hvdyB0aGUgU3dhbCEgQW5kIHdhaXQgZm9yIGNvbmZpcm1hdGlvbiBvciBkaW1pc3NhbC5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3dhbC5maXJlKG9wdGlvbnMpO1xuXG4gICAgICAgIC8vPT4gRW1pdCBvbiAoY29uZmlybSkgb3IgKGNhbmNlbClcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpcm0uZW1pdChyZXN1bHQudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwuZW1pdChyZXN1bHQuZGlzbWlzcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgbW9kYWwsIGlmIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXN1bHQgVGhlIHZhbHVlIHRoYXQgdGhlIG1vZGFsIHdpbGwgcmVzb2x2ZSB3aXRoLCB0cmlnZ2VyaW5nIGVpdGhlciAoY29uZmlybSkgb3IgKGNhbmNlbCkuXG4gICAgICogICAgICAgICAgICAgICBJZiB0aGUgYXJndW1lbnQgaXMgbm90IHBhc3NlZCwgKGRpbWlzcykgd2lsbCBlbWl0IGB1bmRlZmluZWRgLlxuICAgICAqICAgICAgICAgICAgICAgU2VlIHtAbGluayBTd2FsLmNsb3NlfVxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBkaXNtaXNzKHJlc3VsdD86IFN3ZWV0QWxlcnRSZXN1bHQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ3VycmVudGx5U2hvd24pIHJldHVybjtcblxuICAgICAgICBjb25zdCBzd2FsID0gYXdhaXQgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5zd2FsO1xuICAgICAgICBzd2FsLmNsb3NlKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBTd2VldEFsZXJ0MiBvcHRpb25zIHdoaWxlIHRoZSBtb2RhbCBpcyBvcGVuZWQsIGNhdXNpbmcgdGhlIG1vZGFsIHRvIHJlLXJlbmRlci5cbiAgICAgKiBJZiB0aGUgbW9kYWwgaXMgbm90IG9wZW5lZCwgdGhlIGNvbXBvbmVudCBvcHRpb25zIHdpbGwgc2ltcGx5IGJlIHVwZGF0ZWQgYW5kIHRoYXQncyBpdC5cbiAgICAgKlxuICAgICAqIC8hXFwgUGxlYXNlIG5vdGUgdGhhdCBub3QgYWxsIFN3ZWV0QWxlcnQyIG9wdGlvbnMgYXJlIHVwZGF0YWJsZSB3aGlsZSB0aGUgbW9kYWwgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgdXBkYXRlKG9wdGlvbnM/OiBTd2VldEFsZXJ0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zd2FsT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNDdXJyZW50bHlTaG93bikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IHN3YWwgPSBhd2FpdCB0aGlzLnN3ZWV0QWxlcnQyTG9hZGVyLnN3YWw7XG4gICAgICAgIGNvbnN0IGFsbE9wdGlvbnMgPSB0aGlzLnN3YWxPcHRpb25zO1xuXG4gICAgICAgIGNvbnN0IHVwZGF0YWJsZU9wdGlvbnMgPSBPYmplY3Qua2V5cyhhbGxPcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KToga2V5IGlzIGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zID0+IHN3YWwuaXNVcGRhdGFibGVQYXJhbWV0ZXIoa2V5KSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBhbGxPcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sIHt9IGFzIHsgW1AgaW4ga2V5b2YgU3dlZXRBbGVydE9wdGlvbnNdOiBhbnkgfSk7XG5cbiAgICAgICAgc3dhbC51cGRhdGUodXBkYXRhYmxlT3B0aW9ucyk7XG4gICAgfVxufVxuIl19