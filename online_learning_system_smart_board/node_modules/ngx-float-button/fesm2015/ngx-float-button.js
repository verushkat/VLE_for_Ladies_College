import { Injectable, Component, Input, Output, EventEmitter, ViewChild, ChangeDetectionStrategy, ContentChildren, ChangeDetectorRef, NgModule, defineInjectable } from '@angular/core';
import { Subject, BehaviorSubject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class NgxFloatButtonService {
    constructor() { }
}
NgxFloatButtonService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NgxFloatButtonService.ctorParameters = () => [];
/** @nocollapse */ NgxFloatButtonService.ngInjectableDef = defineInjectable({ factory: function NgxFloatButtonService_Factory() { return new NgxFloatButtonService(); }, token: NgxFloatButtonService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class NgxFloatItemButtonComponent {
    constructor() {
        this.color = 'white';
        this.disabled = false;
        this.clicked = new EventEmitter();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    emitClickEvent($event) {
        if (this.disabled) {
            return this.disabled;
        }
        this.clicked.emit($event);
    }
}
NgxFloatItemButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-float-item-button',
                template: `
    <div #elementref class="item {{ disabled ? 'disabled' : ''}}" (click)="emitClickEvent($event)">
        <div class="content-wrapper" #contentref>
          <div class="content" [style.display]="content ? 'block' : 'none'">{{content}}</div>
        </div>
        <a class="fab-item" [style.backgroundColor]="color">
           <mat-icon> {{ icon }} </mat-icon>
        </a>
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
      .item {
        width: 250px;
        height: 40px;
        left: -203px;
        transform: translate3d(0, 0, 0);
        transition: transform, opacity ease-out 200ms;
        transition-timing-function: cubic-bezier(0.165, 0.84, 0.44, 1);
        transition-duration: 180ms;
        position: absolute;
        cursor: pointer;
        top: 5px;
        display: flex;
        justify-content: flex-end;
        align-items: center;
      }

      .item.disabled {
        pointer-events: none;
      }

      .item.disabled .fab-item {
        background-color: lightgray;
      }

      .content {
        background: #333333;
        margin-right: 50px;
        line-height: 25px;
        color: white;
        padding: 2px 7px;
        border-radius: 3px;
        display: none;
        font-size: 12px;
        height: 25px;
        margin-top: 4px;
        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
      }

      .fab-item {
        right: 0;
        background: white;
        border-radius: 100%;
        width: 40px;
        height: 40px;
        position: absolute;
        color: #797979;
        text-align: center;
        cursor: pointer;
        line-height: 50px;
        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
      }
    `]
            }] }
];
NgxFloatItemButtonComponent.propDecorators = {
    icon: [{ type: Input }],
    content: [{ type: Input }],
    color: [{ type: Input }],
    disabled: [{ type: Input }],
    clicked: [{ type: Output }],
    elementref: [{ type: ViewChild, args: ['elementref',] }],
    contentref: [{ type: ViewChild, args: ['contentref',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class NgxFloatButtonComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        this.cd = cd;
        this.spaceBetweenButtons = 55;
        this.color = '#dd0031';
        this.disabled = false;
        this.events = new Subject();
        this._destroy$ = new Subject();
        this.state = new BehaviorSubject({
            display: false,
            direction: 'top',
            event: 'start',
            spaceBetweenButtons: this.spaceBetweenButtons
        });
    }
    /**
     * @return {?}
     */
    toggle() {
        if (this.disabled) {
            return this.disabled;
        }
        this.state.next(Object.assign({}, this.state.getValue(), { display: !this.state.getValue().display, event: !this.state.getValue().display ? 'open' : 'close' }));
    }
    // only top and bottom support content element
    /**
     * @return {?}
     */
    checkDirectionType() {
        if (this.buttons.toArray()) {
            /** @type {?} */
            let display = 'block';
            if (this.direction === 'right' || this.direction === 'left') {
                display = 'none';
            }
            this.buttons.toArray().forEach(element => {
                element.contentref.nativeElement.style.display = display;
            });
        }
    }
    // transition
    /**
     * @param {?} eventType
     * @return {?}
     */
    animateButtons(eventType) {
        this.buttons.toArray().forEach((btn, i) => {
            i += 1;
            /** @type {?} */
            const style = btn.elementref.nativeElement.style;
            if (eventType !== 'directionChanged' && this.state.getValue().display) {
                style['transform'] = 'scale(1)';
                style['transition-duration'] = '0s';
                if (btn.timeout) {
                    clearTimeout(btn.timeout);
                }
            }
            setTimeout(() => {
                style['transition-duration'] = this.state.getValue().display ? `${90 + 100 * i}ms` : '';
                style['transform'] = this.state.getValue().display ? this.getTranslate(i) : '';
            }, 50);
            if (eventType !== 'directionChanged' && !this.state.getValue().display) {
                btn.timeout = setTimeout(() => {
                    style['transform'] = 'scale(0)';
                }, 90 + 100 * i);
            }
        });
    }
    // get transition direction
    /**
     * @param {?} i
     * @return {?}
     */
    getTranslate(i) {
        /** @type {?} */
        let animation;
        switch (this.direction) {
            case 'right':
                animation = `translate3d(${this.state.getValue().spaceBetweenButtons * i}px,0,0)`;
                break;
            case 'bottom':
                animation = `translate3d(0,${this.state.getValue().spaceBetweenButtons * i}px,0)`;
                break;
            case 'left':
                animation = `translate3d(-${this.state.getValue().spaceBetweenButtons * i}px,0,0)`;
                break;
            default:
                animation = `translate3d(0,-${this.state.getValue().spaceBetweenButtons * i}px,0)`;
                break;
        }
        return animation;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.direction) {
            // first time to check
            this.checkDirectionType();
        }
        this.buttons.toArray().map(v => {
            v.clicked.pipe(takeUntil(this._destroy$)).subscribe(() => {
                this.state.next(Object.assign({}, this.state.getValue(), { display: false, event: 'close' }));
            });
        });
        this.state.pipe(takeUntil(this._destroy$)).subscribe(v => {
            this.animateButtons(v.event);
            this.events.next({
                display: v.display,
                event: v.event,
                direction: v.direction
            });
        });
    }
    // if @Input values changes, we need check the direction type
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.direction && !changes.direction.firstChange) {
            this.state.next(Object.assign({}, this.state.getValue(), { event: 'directionChanged', direction: changes.direction.currentValue }));
            // if changes happens
            this.checkDirectionType();
        }
        if (changes.open && changes.open.currentValue) {
            this.open.pipe(takeUntil(this._destroy$)).subscribe(v => {
                if (v !== this.state.getValue().display) {
                    this.state.next(Object.assign({}, this.state.getValue(), { event: v ? 'open' : 'close', display: v }));
                    // make angular happy
                    this.cd.markForCheck();
                }
            });
        }
        if (changes.spaceBetweenButtons && changes.spaceBetweenButtons.currentValue) {
            this.state.next(Object.assign({}, this.state.getValue(), { event: 'spaceBetweenButtonsChanged', spaceBetweenButtons: changes.spaceBetweenButtons.currentValue }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy$.next();
    }
}
NgxFloatButtonComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'ngx-float-button',
                template: `
    <nav class="fab-menu" [class.active]="(state | async).display">
        <a class="fab-toggle" (click)="toggle()" [style.backgroundColor]="color">
          <mat-icon> {{icon}} </mat-icon>
        </a>
        <ng-content></ng-content>
    </nav>
  `,
                styles: [`
      :host {
        position: absolute;
      }

      .fab-menu {
        box-sizing: border-box;
        font-size: 20px;
        width: 55px;
        height: 55px;
        text-align: left;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 9;
      }

      .fab-toggle {
        border-radius: 100%;
        width: 40px;
        height: 40px;
        color: white;
        text-align: center;
        line-height: 50px;
        transform: translate3d(0, 0, 0);
        transition: all ease-out 200ms;
        z-index: 2;
        transition-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1.275);
        transition-duration: 400ms;
        transform: scale(1.1, 1.1) translate3d(0, 0, 0);
        cursor: pointer;
        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
      }

      .fab-menu .fab-toggle:hover {
        transform: scale(1.2, 1.2) translate3d(0, 0, 0);
      }

      .fab-menu /deep/ .item {
        opacity: 0;
      }

      .fab-menu.active /deep/ .item {
        opacity: 1;
      }

      .fab-menu.active /deep/ .content-wrapper {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .fab-menu.active /deep/ .content {
        display: block;
      }

      .fab-menu.active .fab-toggle {
        transition-timing-function: linear;
        transition-duration: 200ms;
        transform: scale(0.8, 0.8) translate3d(0, 0, 0);
      }
    `]
            }] }
];
/** @nocollapse */
NgxFloatButtonComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NgxFloatButtonComponent.propDecorators = {
    icon: [{ type: Input }],
    direction: [{ type: Input }],
    spaceBetweenButtons: [{ type: Input }],
    open: [{ type: Input }],
    color: [{ type: Input }],
    disabled: [{ type: Input }],
    events: [{ type: Output }],
    buttons: [{ type: ContentChildren, args: [NgxFloatItemButtonComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class NgxFloatButtonModule {
}
NgxFloatButtonModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, MatIconModule],
                declarations: [NgxFloatButtonComponent, NgxFloatItemButtonComponent],
                exports: [NgxFloatButtonComponent, NgxFloatItemButtonComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

export { NgxFloatButtonService, NgxFloatButtonComponent, NgxFloatButtonModule, NgxFloatItemButtonComponent as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWZsb2F0LWJ1dHRvbi5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vbmd4LWZsb2F0LWJ1dHRvbi9saWIvbmd4LWZsb2F0LWJ1dHRvbi5zZXJ2aWNlLnRzIiwibmc6Ly9uZ3gtZmxvYXQtYnV0dG9uL2xpYi9uZ3gtZmxvYXQtaXRlbS1idXR0b24uY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtZmxvYXQtYnV0dG9uL2xpYi9uZ3gtZmxvYXQtYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LWZsb2F0LWJ1dHRvbi9saWIvbmd4LWZsb2F0LWJ1dHRvbi5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBOZ3hGbG9hdEJ1dHRvblNlcnZpY2Uge1xuXG4gIGNvbnN0cnVjdG9yKCkgeyB9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgVmlld0NoaWxkLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICduZ3gtZmxvYXQtaXRlbS1idXR0b24nLFxyXG4gIHN0eWxlczogW1xyXG4gICAgYFxyXG4gICAgICAuaXRlbSB7XHJcbiAgICAgICAgd2lkdGg6IDI1MHB4O1xyXG4gICAgICAgIGhlaWdodDogNDBweDtcclxuICAgICAgICBsZWZ0OiAtMjAzcHg7XHJcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcclxuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0sIG9wYWNpdHkgZWFzZS1vdXQgMjAwbXM7XHJcbiAgICAgICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjE2NSwgMC44NCwgMC40NCwgMSk7XHJcbiAgICAgICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTgwbXM7XHJcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICB0b3A6IDVweDtcclxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XHJcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLml0ZW0uZGlzYWJsZWQge1xyXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuaXRlbS5kaXNhYmxlZCAuZmFiLWl0ZW0ge1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGxpZ2h0Z3JheTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmNvbnRlbnQge1xyXG4gICAgICAgIGJhY2tncm91bmQ6ICMzMzMzMzM7XHJcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA1MHB4O1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyNXB4O1xyXG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgICAgICBwYWRkaW5nOiAycHggN3B4O1xyXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcclxuICAgICAgICBkaXNwbGF5OiBub25lO1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgICAgICBoZWlnaHQ6IDI1cHg7XHJcbiAgICAgICAgbWFyZ2luLXRvcDogNHB4O1xyXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC4yNik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5mYWItaXRlbSB7XHJcbiAgICAgICAgcmlnaHQ6IDA7XHJcbiAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7XHJcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcclxuICAgICAgICB3aWR0aDogNDBweDtcclxuICAgICAgICBoZWlnaHQ6IDQwcHg7XHJcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgIGNvbG9yOiAjNzk3OTc5O1xyXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgbGluZS1oZWlnaHQ6IDUwcHg7XHJcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggNXB4IDAgcmdiYSgwLCAwLCAwLCAwLjI2KTtcclxuICAgICAgfVxyXG4gICAgYFxyXG4gIF0sXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgIDxkaXYgI2VsZW1lbnRyZWYgY2xhc3M9XCJpdGVtIHt7IGRpc2FibGVkID8gJ2Rpc2FibGVkJyA6ICcnfX1cIiAoY2xpY2spPVwiZW1pdENsaWNrRXZlbnQoJGV2ZW50KVwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50LXdyYXBwZXJcIiAjY29udGVudHJlZj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCIgW3N0eWxlLmRpc3BsYXldPVwiY29udGVudCA/ICdibG9jaycgOiAnbm9uZSdcIj57e2NvbnRlbnR9fTwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxhIGNsYXNzPVwiZmFiLWl0ZW1cIiBbc3R5bGUuYmFja2dyb3VuZENvbG9yXT1cImNvbG9yXCI+XHJcbiAgICAgICAgICAgPG1hdC1pY29uPiB7eyBpY29uIH19IDwvbWF0LWljb24+XHJcbiAgICAgICAgPC9hPlxyXG4gICAgPC9kaXY+XHJcbiAgYCxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4RmxvYXRJdGVtQnV0dG9uQ29tcG9uZW50IHtcclxuICBASW5wdXQoKVxyXG4gIGljb246IHN0cmluZztcclxuICBASW5wdXQoKVxyXG4gIGNvbnRlbnQ6IHN0cmluZztcclxuICBASW5wdXQoKVxyXG4gIGNvbG9yID0gJ3doaXRlJztcclxuICBASW5wdXQoKVxyXG4gIGRpc2FibGVkID0gZmFsc2U7XHJcblxyXG4gIEBPdXRwdXQoKVxyXG4gIGNsaWNrZWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICBAVmlld0NoaWxkKCdlbGVtZW50cmVmJylcclxuICBlbGVtZW50cmVmO1xyXG5cclxuICBAVmlld0NoaWxkKCdjb250ZW50cmVmJylcclxuICBjb250ZW50cmVmO1xyXG5cclxuICBlbWl0Q2xpY2tFdmVudCgkZXZlbnQ6IEV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcclxuICAgIH1cclxuICAgIHRoaXMuY2xpY2tlZC5lbWl0KCRldmVudCk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBBZnRlckNvbnRlbnRJbml0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgT25DaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCwgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IE5neEZsb2F0SXRlbUJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4vbmd4LWZsb2F0LWl0ZW0tYnV0dG9uLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgc2VsZWN0b3I6ICduZ3gtZmxvYXQtYnV0dG9uJyxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgICAgOmhvc3Qge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB9XG5cbiAgICAgIC5mYWItbWVudSB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICAgICAgd2lkdGg6IDU1cHg7XG4gICAgICAgIGhlaWdodDogNTVweDtcbiAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgei1pbmRleDogOTtcbiAgICAgIH1cblxuICAgICAgLmZhYi10b2dnbGUge1xuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDAlO1xuICAgICAgICB3aWR0aDogNDBweDtcbiAgICAgICAgaGVpZ2h0OiA0MHB4O1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDUwcHg7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCBlYXNlLW91dCAyMDBtcztcbiAgICAgICAgei1pbmRleDogMjtcbiAgICAgICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjE3NSwgMC44ODUsIDAuMzIsIDEuMjc1KTtcbiAgICAgICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogNDAwbXM7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4xLCAxLjEpIHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC4yNik7XG4gICAgICB9XG5cbiAgICAgIC5mYWItbWVudSAuZmFiLXRvZ2dsZTpob3ZlciB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4yLCAxLjIpIHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICAuZmFiLW1lbnUgL2RlZXAvIC5pdGVtIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgIH1cblxuICAgICAgLmZhYi1tZW51LmFjdGl2ZSAvZGVlcC8gLml0ZW0ge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuXG4gICAgICAuZmFiLW1lbnUuYWN0aXZlIC9kZWVwLyAuY29udGVudC13cmFwcGVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICB9XG5cbiAgICAgIC5mYWItbWVudS5hY3RpdmUgL2RlZXAvIC5jb250ZW50IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIC5mYWItbWVudS5hY3RpdmUgLmZhYi10b2dnbGUge1xuICAgICAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogbGluZWFyO1xuICAgICAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAyMDBtcztcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjgsIDAuOCkgdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICB9XG4gICAgYFxuICBdLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuYXYgY2xhc3M9XCJmYWItbWVudVwiIFtjbGFzcy5hY3RpdmVdPVwiKHN0YXRlIHwgYXN5bmMpLmRpc3BsYXlcIj5cbiAgICAgICAgPGEgY2xhc3M9XCJmYWItdG9nZ2xlXCIgKGNsaWNrKT1cInRvZ2dsZSgpXCIgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XCJjb2xvclwiPlxuICAgICAgICAgIDxtYXQtaWNvbj4ge3tpY29ufX0gPC9tYXQtaWNvbj5cbiAgICAgICAgPC9hPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9uYXY+XG4gIGBcbn0pXG5leHBvcnQgY2xhc3MgTmd4RmxvYXRCdXR0b25Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XG4gIHB1YmxpYyBzdGF0ZTogQmVoYXZpb3JTdWJqZWN0PGFueT47XG5cbiAgQElucHV0KClcbiAgaWNvbjogc3RyaW5nO1xuICBASW5wdXQoKVxuICBkaXJlY3Rpb246IHN0cmluZztcbiAgQElucHV0KClcbiAgc3BhY2VCZXR3ZWVuQnV0dG9ucyA9IDU1O1xuICBASW5wdXQoKVxuICBvcGVuOiBTdWJqZWN0PGJvb2xlYW4+O1xuICBASW5wdXQoKVxuICBjb2xvciA9ICcjZGQwMDMxJztcbiAgQElucHV0KClcbiAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgQE91dHB1dCgpXG4gIGV2ZW50czogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3QoKTtcbiAgQENvbnRlbnRDaGlsZHJlbihOZ3hGbG9hdEl0ZW1CdXR0b25Db21wb25lbnQpXG4gIGJ1dHRvbnM7XG5cbiAgcHJpdmF0ZSBfZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBCZWhhdmlvclN1YmplY3Qoe1xuICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICBkaXJlY3Rpb246ICd0b3AnLFxuICAgICAgZXZlbnQ6ICdzdGFydCcsXG4gICAgICBzcGFjZUJldHdlZW5CdXR0b25zOiB0aGlzLnNwYWNlQmV0d2VlbkJ1dHRvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLm5leHQoe1xuICAgICAgLi4udGhpcy5zdGF0ZS5nZXRWYWx1ZSgpLFxuICAgICAgZGlzcGxheTogIXRoaXMuc3RhdGUuZ2V0VmFsdWUoKS5kaXNwbGF5LFxuICAgICAgZXZlbnQ6ICF0aGlzLnN0YXRlLmdldFZhbHVlKCkuZGlzcGxheSA/ICdvcGVuJyA6ICdjbG9zZSdcbiAgICB9KTtcbiAgfVxuXG4gIC8vIG9ubHkgdG9wIGFuZCBib3R0b20gc3VwcG9ydCBjb250ZW50IGVsZW1lbnRcbiAgcHJpdmF0ZSBjaGVja0RpcmVjdGlvblR5cGUoKSB7XG4gICAgaWYgKHRoaXMuYnV0dG9ucy50b0FycmF5KCkpIHtcbiAgICAgIGxldCBkaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncmlnaHQnIHx8IHRoaXMuZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5idXR0b25zLnRvQXJyYXkoKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBlbGVtZW50LmNvbnRlbnRyZWYubmF0aXZlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRyYW5zaXRpb25cbiAgcHJpdmF0ZSBhbmltYXRlQnV0dG9ucyhldmVudFR5cGUpIHtcbiAgICB0aGlzLmJ1dHRvbnMudG9BcnJheSgpLmZvckVhY2goKGJ0biwgaSkgPT4ge1xuICAgICAgaSArPSAxO1xuICAgICAgY29uc3Qgc3R5bGUgPSBidG4uZWxlbWVudHJlZi5uYXRpdmVFbGVtZW50LnN0eWxlO1xuXG4gICAgICBpZiAoZXZlbnRUeXBlICE9PSAnZGlyZWN0aW9uQ2hhbmdlZCcgJiYgdGhpcy5zdGF0ZS5nZXRWYWx1ZSgpLmRpc3BsYXkpIHtcbiAgICAgICAgc3R5bGVbJ3RyYW5zZm9ybSddID0gJ3NjYWxlKDEpJztcbiAgICAgICAgc3R5bGVbJ3RyYW5zaXRpb24tZHVyYXRpb24nXSA9ICcwcyc7XG5cbiAgICAgICAgaWYgKGJ0bi50aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGJ0bi50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc3R5bGVbJ3RyYW5zaXRpb24tZHVyYXRpb24nXSA9IHRoaXMuc3RhdGUuZ2V0VmFsdWUoKS5kaXNwbGF5ID8gYCR7OTAgKyAxMDAgKiBpfW1zYCA6ICcnO1xuICAgICAgICBzdHlsZVsndHJhbnNmb3JtJ10gPSB0aGlzLnN0YXRlLmdldFZhbHVlKCkuZGlzcGxheSA/IHRoaXMuZ2V0VHJhbnNsYXRlKGkpIDogJyc7XG4gICAgICB9LCA1MCk7XG5cbiAgICAgIGlmIChldmVudFR5cGUgIT09ICdkaXJlY3Rpb25DaGFuZ2VkJyAmJiAhdGhpcy5zdGF0ZS5nZXRWYWx1ZSgpLmRpc3BsYXkpIHtcbiAgICAgICAgYnRuLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzdHlsZVsndHJhbnNmb3JtJ10gPSAnc2NhbGUoMCknO1xuICAgICAgICB9LCA5MCArIDEwMCAqIGkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gZ2V0IHRyYW5zaXRpb24gZGlyZWN0aW9uXG4gIHByaXZhdGUgZ2V0VHJhbnNsYXRlKGkpIHtcbiAgICBsZXQgYW5pbWF0aW9uO1xuXG4gICAgc3dpdGNoICh0aGlzLmRpcmVjdGlvbikge1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBhbmltYXRpb24gPSBgdHJhbnNsYXRlM2QoJHt0aGlzLnN0YXRlLmdldFZhbHVlKCkuc3BhY2VCZXR3ZWVuQnV0dG9ucyAqIGl9cHgsMCwwKWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgYW5pbWF0aW9uID0gYHRyYW5zbGF0ZTNkKDAsJHt0aGlzLnN0YXRlLmdldFZhbHVlKCkuc3BhY2VCZXR3ZWVuQnV0dG9ucyAqIGl9cHgsMClgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBhbmltYXRpb24gPSBgdHJhbnNsYXRlM2QoLSR7dGhpcy5zdGF0ZS5nZXRWYWx1ZSgpLnNwYWNlQmV0d2VlbkJ1dHRvbnMgKiBpfXB4LDAsMClgO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFuaW1hdGlvbiA9IGB0cmFuc2xhdGUzZCgwLC0ke3RoaXMuc3RhdGUuZ2V0VmFsdWUoKS5zcGFjZUJldHdlZW5CdXR0b25zICogaX1weCwwKWA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb247XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIHRvIGNoZWNrXG4gICAgICB0aGlzLmNoZWNrRGlyZWN0aW9uVHlwZSgpO1xuICAgIH1cblxuICAgIHRoaXMuYnV0dG9ucy50b0FycmF5KCkubWFwKHYgPT4ge1xuICAgICAgdi5jbGlja2VkLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAuLi50aGlzLnN0YXRlLmdldFZhbHVlKCksXG4gICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgZXZlbnQ6ICdjbG9zZSdcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuc3RhdGUucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSQpKS5zdWJzY3JpYmUodiA9PiB7XG4gICAgICB0aGlzLmFuaW1hdGVCdXR0b25zKHYuZXZlbnQpO1xuXG4gICAgICB0aGlzLmV2ZW50cy5uZXh0KHtcbiAgICAgICAgZGlzcGxheTogdi5kaXNwbGF5LFxuICAgICAgICBldmVudDogdi5ldmVudCxcbiAgICAgICAgZGlyZWN0aW9uOiB2LmRpcmVjdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBpZiBASW5wdXQgdmFsdWVzIGNoYW5nZXMsIHdlIG5lZWQgY2hlY2sgdGhlIGRpcmVjdGlvbiB0eXBlXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5kaXJlY3Rpb24gJiYgIWNoYW5nZXMuZGlyZWN0aW9uLmZpcnN0Q2hhbmdlKSB7XG4gICAgICB0aGlzLnN0YXRlLm5leHQoe1xuICAgICAgICAuLi50aGlzLnN0YXRlLmdldFZhbHVlKCksXG4gICAgICAgIGV2ZW50OiAnZGlyZWN0aW9uQ2hhbmdlZCcsXG4gICAgICAgIGRpcmVjdGlvbjogY2hhbmdlcy5kaXJlY3Rpb24uY3VycmVudFZhbHVlXG4gICAgICB9KTtcbiAgICAgIC8vIGlmIGNoYW5nZXMgaGFwcGVuc1xuICAgICAgdGhpcy5jaGVja0RpcmVjdGlvblR5cGUoKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlcy5vcGVuICYmIGNoYW5nZXMub3Blbi5jdXJyZW50VmFsdWUpIHtcbiAgICAgIHRoaXMub3Blbi5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95JCkpLnN1YnNjcmliZSh2ID0+IHtcbiAgICAgICAgaWYgKHYgIT09IHRoaXMuc3RhdGUuZ2V0VmFsdWUoKS5kaXNwbGF5KSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RhdGUuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgIGV2ZW50OiB2ID8gJ29wZW4nIDogJ2Nsb3NlJyxcbiAgICAgICAgICAgIGRpc3BsYXk6IHZcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIG1ha2UgYW5ndWxhciBoYXBweVxuICAgICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLnNwYWNlQmV0d2VlbkJ1dHRvbnMgJiYgY2hhbmdlcy5zcGFjZUJldHdlZW5CdXR0b25zLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgdGhpcy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgLi4udGhpcy5zdGF0ZS5nZXRWYWx1ZSgpLFxuICAgICAgICBldmVudDogJ3NwYWNlQmV0d2VlbkJ1dHRvbnNDaGFuZ2VkJyxcbiAgICAgICAgc3BhY2VCZXR3ZWVuQnV0dG9uczogY2hhbmdlcy5zcGFjZUJldHdlZW5CdXR0b25zLmN1cnJlbnRWYWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZGVzdHJveSQubmV4dCgpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE1hdEljb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBOZ3hGbG9hdEJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4vbmd4LWZsb2F0LWJ1dHRvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmd4RmxvYXRJdGVtQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9uZ3gtZmxvYXQtaXRlbS1idXR0b24uY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWF0SWNvbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW05neEZsb2F0QnV0dG9uQ29tcG9uZW50LCBOZ3hGbG9hdEl0ZW1CdXR0b25Db21wb25lbnRdLFxuICBleHBvcnRzOiBbTmd4RmxvYXRCdXR0b25Db21wb25lbnQsIE5neEZsb2F0SXRlbUJ1dHRvbkNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgTmd4RmxvYXRCdXR0b25Nb2R1bGUge31cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsTUFLYSxxQkFBcUI7SUFFaEMsaUJBQWlCOzs7WUFMbEIsVUFBVSxT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